<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Game</title>
    <style>
body {
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    background-color: #f0f0f0;
    margin: 0;
}
#mazeCanvas {
    border: 1px solid black;
}
    </style>
</head>
<body>
    <canvas id="mazeCanvas"></canvas>
    <script>
const canvas = document.getElementById('mazeCanvas');
const ctx = canvas.getContext('2d');

const size = 20; // 每个迷宫单元的大小
const width = 800;
const height = 600;
canvas.width = width;
canvas.height = height;
const cols = Math.floor(width / size);
const rows = Math.floor(height / size);

let grid = [];
let current;
let stack = [];
let player;
let offsetX = 0;
let offsetY = 0;

class Cell {
    constructor(x, y) {
        this.x = x;
        this.y = y;
        this.walls = [true, true, true, true]; // top, right, bottom, left
        this.visited = false;
    }

    show() {
        let x = (this.x - offsetX) * size;
        let y = (this.y - offsetY) * size;

        ctx.strokeStyle = 'black';
        if (this.walls[0]) {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x + size, y);
            ctx.stroke();
        }
        if (this.walls[1]) {
            ctx.beginPath();
            ctx.moveTo(x + size, y);
            ctx.lineTo(x + size, y + size);
            ctx.stroke();
        }
        if (this.walls[2]) {
            ctx.beginPath();
            ctx.moveTo(x + size, y + size);
            ctx.lineTo(x, y + size);
            ctx.stroke();
        }
        if (this.walls[3]) {
            ctx.beginPath();
            ctx.moveTo(x, y + size);
            ctx.lineTo(x, y);
            ctx.stroke();
        }

        if (this.visited) {
            ctx.fillStyle = 'rgba(0, 0, 255, 0.5)';
            ctx.fillRect(x, y, size, size);
        }
    }

    checkNeighbors() {
        let neighbors = [];

        let top = grid[index(this.x, this.y - 1)];
        let right = grid[index(this.x + 1, this.y)];
        let bottom = grid[index(this.x, this.y + 1)];
        let left = grid[index(this.x - 1, this.y)];

        if (top && !top.visited) {
            neighbors.push(top);
        }
        if (right && !right.visited) {
            neighbors.push(right);
        }
        if (bottom && !bottom.visited) {
            neighbors.push(bottom);
        }
        if (left && !left.visited) {
            neighbors.push(left);
        }

        if (neighbors.length > 0) {
            let r = Math.floor(Math.random() * neighbors.length);
            return neighbors[r];
        } else {
            return undefined;
        }
    }

    highlight() {
        let x = (this.x - offsetX) * size;
        let y = (this.y - offsetY) * size;
        ctx.fillStyle = 'yellow';
        ctx.fillRect(x, y, size, size);
    }
}

function setup() {
    for (let y = 0; y < rows; y++) {
        for (let x = 0; x < cols; x++) {
            let cell = new Cell(x, y);
            grid.push(cell);
        }
    }

    current = grid[0];
    player = { x: 0, y: 0 };
}

function index(x, y) {
    if (x < 0 || y < 0 || x > cols - 1 || y > rows - 1) {
        return -1;
    }
    return x + y * cols;
}

function removeWalls(a, b) {
    let x = a.x - b.x;
    if (x === 1) {
        a.walls[3] = false;
        b.walls[1] = false;
    } else if (x === -1) {
        a.walls[1] = false;
        b.walls[3] = false;
    }
    let y = a.y - b.y;
    if (y === 1) {
        a.walls[0] = false;
        b.walls[2] = false;
    } else if (y === -1) {
        a.walls[2] = false;
        b.walls[0] = false;
    }
}

function draw() {
    ctx.clearRect(0, 0, width, height);
    for (let i = 0; i < grid.length; i++) {
        if (grid[i].x >= offsetX && grid[i].x < offsetX + cols && grid[i].y >= offsetY && grid[i].y < offsetY + rows) {
            grid[i].show();
        }
    }

    current.visited = true;
    current.highlight();
    let next = current.checkNeighbors();
    if (next) {
        next.visited = true;
        stack.push(current);
        removeWalls(current, next);
        current = next;
    } else if (stack.length > 0) {
        current = stack.pop();
    }

    drawPlayer();
}

function drawPlayer() {
    ctx.fillStyle = 'red';
    ctx.beginPath();
    ctx.arc((player.x - offsetX + 0.5) * size, (player.y - offsetY + 0.5) * size, size / 3, 0, 2 * Math.PI);
    ctx.fill();
}

function movePlayer(dx, dy) {
    let newX = player.x + dx;
    let newY = player.y + dy;
    let cell = grid[index(player.x, player.y)];

    if (dx === -1 && !cell.walls[3]) player.x = newX;
    if (dx === 1 && !cell.walls[1]) player.x = newX;
    if (dy === -1 && !cell.walls[0]) player.y = newY;
    if (dy === 1 && !cell.walls[2]) player.y = newY;

    if (player.x < offsetX + 2) offsetX = Math.max(0, offsetX - 1);
    if (player.x > offsetX + cols - 3) offsetX = Math.min(cols - 1, offsetX + 1);
    if (player.y < offsetY + 2) offsetY = Math.max(0, offsetY - 1);
    if (player.y > offsetY + rows - 3) offsetY = Math.min(rows - 1, offsetY + 1);
}

document.addEventListener('keydown', function(event) {
    if (event.key === 'ArrowUp') movePlayer(0, -1);
    if (event.key === 'ArrowDown') movePlayer(0, 1);
    if (event.key === 'ArrowLeft') movePlayer(-1, 0);
    if (event.key === 'ArrowRight') movePlayer(1, 0);
    draw();
});

setup();
let generating = true;

function animate() {
    if (generating) {
        draw();
        if (stack.length === 0) {
            generating = false;
        }
    }
    requestAnimationFrame(animate);
}

animate();
    </script>
</body>
</html>